package edu.ucsd.livesearch.result.processors;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.FilenameUtils;
import org.apache.xpath.XPathAPI;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import edu.ucsd.livesearch.dataset.mapper.ResultFileMapper;
import edu.ucsd.livesearch.result.parsers.Result;
import edu.ucsd.livesearch.result.parsers.ResultHit;
import edu.ucsd.livesearch.util.FileIOUtils;

public class MappedFilenameProcessor
implements ResultProcessor
{
	/*========================================================================
	 * Constants
	 *========================================================================*/
	private static final Logger logger =
		LoggerFactory.getLogger(MappedFilenameProcessor.class);
	private static final Pattern FILE_URI_HOST_PATTERN =
		Pattern.compile("[^/]*/(.*)");
	
	/*========================================================================
	 * Properties
	 *========================================================================*/
	private String field;
	private boolean isAttribute = false;
	private Map<String, String> filenameMap;
	
	/*========================================================================
	 * Public interface methods
	 *========================================================================*/
	public void processHit(ResultHit hit, Result result) {
		if (hit == null || result == null)
			return;
		String field = getField();
		if (field == null)
			return;
		// extract filename from original result file column value
		String fieldValue = hit.getFieldValue(field);
		// the filename value may be stored as an attribute,
		// if it was generated by a previous processor
		if (fieldValue == null) {
			fieldValue = hit.getAttribute(field);
			isAttribute = true;
		}
		if (fieldValue == null)
			return;
		// parse user-specified file mappings in params.xml, if necessary
		if (filenameMap == null)
			buildFilenameMap(result);
		// attempt to resolve this filename against the populated map
		String sourceFilename = getMappedFilename(fieldValue);
		// if not found, then try stripping off any file URI stuff
		if (sourceFilename == null) {
			fieldValue = resolveFilename(
				fieldValue, ResultFileMapper.FILE_URI_PROTOCOL_PATTERN);
			sourceFilename = getMappedFilename(fieldValue);
		}
		// if still not found, maybe the mapped value has
		// a leading slash that the field value doesn't
		if (sourceFilename == null) {
			fieldValue = String.format("/%s", fieldValue);
			sourceFilename = getMappedFilename(fieldValue);
		}
		if (sourceFilename != null) {
			if (isAttribute)
				hit.setAttribute(field, sourceFilename);
			else hit.setFieldValue(field, sourceFilename);
		}
		// add unmapped filename as a special hit attribute
		hit.setAttribute("unmappedFilename", fieldValue);
	}
	
	/*========================================================================
	 * Property accessor methods
	 *========================================================================*/
	public String getField() {
		return field;
	}
	
	public void setField(String field) {
		this.field = field;
	}
	
	/*========================================================================
	 * Convenience methods
	 *========================================================================*/
	private void buildFilenameMap(Result result) {
		try {
			Document document = FileIOUtils.parseXML(
				result.getTask().getPath("params/params.xml"));
			if (document == null)
				throw new NullPointerException(
					"Parameters XML document could not be parsed.");
			// generate mappings for all submitted filenames
			NodeList mappings = XPathAPI.selectNodeList(
				document, "//parameter[@name='result_file_mapping']");
			if (mappings != null && mappings.getLength() > 0) {
				Map<String, String> map =
					new HashMap<String, String>(mappings.getLength());
				for (int i=0; i<mappings.getLength(); i++) {
					String value =
						mappings.item(i).getFirstChild().getNodeValue();
					// each "result_file_mapping" parameter should have
					// as its value a string with the following format:
					// <result_file>#<referenced_filename>|<source_filename>
					String[] tokens = value.split("\\|");
					if (tokens == null || tokens.length != 2)
						throw new IllegalArgumentException(String.format(
							"\"result_file_mapping\" parameter value " +
							"\"%s\" is invalid - it should contain two " +
							"tokens separated by a pipe (\"|\") character.",
							value));
					// split the mapped value to extract the referenced filename
					String[] mapped = tokens[0].split(
						ResultFileMapper.EXTRACTED_FILE_DELIMITER);
					if (mapped == null || mapped.length != 2)
						throw new IllegalArgumentException(String.format(
							"\"result_file_mapping\" parameter value " +
							"\"%s\" is invalid - its first token (\"%s\") " +
							"should consist of two values separated by a \"" +
							ResultFileMapper.EXTRACTED_FILE_DELIMITER +
							"\" character.", value, tokens[0]));
					String cleanedMapping = resolveFilename(
						mapped[1], ResultFileMapper.FILE_URI_PROTOCOL_PATTERN);
					map.put(cleanedMapping, tokens[1]);
				}
				if (map.isEmpty() == false)
					filenameMap = map;
			}
		} catch (Throwable error) {
			String errorMessage = "There was an error parsing params.xml to " +
				"build the user-specified filename map.";
			logger.error(errorMessage, error);
			throw new RuntimeException(errorMessage, error);
		}
	}
	
	private String resolveFilename(String filename, Pattern pattern) {
		if (filename == null)
			return null;
		else if (pattern == null)
			return filename;
		// if this filename matches the given pattern, clean it
		Matcher matcher = pattern.matcher(filename);
		if (matcher.matches())
			filename = matcher.group(1);
		return filename;
	}
	
	private String getMappedFilename(String filename) {
		if (filename == null || filenameMap == null || filenameMap.isEmpty())
			return null;
		// first, try checking against the literal filename
		String mapped = filenameMap.get(filename);
		// if nothing was found, the source filename
		// might have had Windows path separators
		if (mapped == null)
			mapped = filenameMap.get(
				FilenameUtils.separatorsToWindows(filename));
		// if nothing was found again, then we might need
		// to strip off more of the file URI
		if (mapped == null)
			mapped = filenameMap.get(
				resolveFilename(filename, FILE_URI_HOST_PATTERN));
		if (mapped == null)
			mapped = filenameMap.get(
				FilenameUtils.separatorsToWindows(
					resolveFilename(filename, FILE_URI_HOST_PATTERN)));
		return mapped;
	}
}
